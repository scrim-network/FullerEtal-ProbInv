daisLoadModel <- function(assimctx=daisassimctx)
{
    if (assimctx$fortran) {
        daisModel <<- F_daisModel
    } else {
        daisModel <<- C_daisModel
        dynUnload("dais_alex")
        dynUnload("dais_kelsey")
        if (assimctx$alex) {
            dynLoad("dais_alex",   srcname=c("dais_alex.c",   "r.c"), extrasrc="r.h")
        } else {
            dynLoad("dais_kelsey", srcname=c("dais_kelsey.c", "r.c"), extrasrc="r.h")
        }
    }
}


    bound.lower <- IP - (IP*0.5)
    bound.upper <- IP + (IP*0.5)

    #Set bounds for gamma and alpha
    bound.lower[1:2] <- c( 1/2, 0)
    bound.upper[1:2] <- c(17/4, 1)

    #Set bounds for bo and s
    bound.lower[10:11] <- c(725, 0.00045)
    bound.upper[10:11] <- c(825, 0.00075)


        print(paste(anom[1], last(anom)))
        print(paste(length(anom), length(proj.mcmc.anomaly[i, ])))
        print(paste(proj.mcmc.1961_1990[i, 1]))


if (0) {

    # Estimate model hindcast from parameter means.
    mean.hind.simulation = iceflux(mean.parameters[ assimctx$mp_indices ], assimctx$hindcast.forcings)
    mean.hind.anomaly = mean.hind.simulation - mean(mean.hind.simulation[assimctx$SL.1961_1990]) 
    mean.hindcast = mean.hind.anomaly + rnorm(length(mean.hind.simulation), mean=0, sd=bias.mean)

    # Estimate model projection from parameter means.
    mean.proj.simulation = iceflux(mean.parameters[ assimctx$mp_indices ], assimctx$project.forcings)
    mean.proj.anomaly = mean.proj.simulation - mean(mean.proj.simulation[assimctx$SL.1961_1990])
    mean.projection = mean.proj.anomaly + rnorm(length(mean.proj.anomaly), mean=0, sd=bias.mean)
}    

F_iceflux <- function(iceflux, forcings)
{
    Volume_F <- daisF(
      tstep = 1,
      b0    = iceflux[10],
      slope = iceflux[11],
      mu    = iceflux[3],
      h0    = iceflux[8],
      c     = iceflux[9],
      P0    = iceflux[5],
      kappa = iceflux[6],
      nu    = iceflux[4],
      f0    = iceflux[7],
      gamma = iceflux[1],
      alpha = iceflux[2],
      Tf    = -1.8,             #Freezing temperature of sea water
      rho_w = 1030,             #Density of sea water [g/cm^3]
      rho_i = 917,              #Density of ice water [g/cm^3]
      rho_m = 4000,             #Density of rock [g/cm^3]
      Toc_0 = 0.72,             #Present day high latitude ocean subsurface temperature [K]
      Rad0  = 1.8636e6,         #Steady state AIS radius for present day Ta and SL [m]
      Ta     = forcings[, 1], 
      SL     = forcings[, 4],
      Toc    = forcings[, 2],
      dSL    = forcings[, 3])

    return (Volume_F)
}

daisModel <- function(mp, assimctx)
{
    # this was quite a bit slower
    return (iceflux(mp, assimctx$frc))
}


    iceflux <- function(mp, forcings)
    {
        np <- nrow(forcings)
        if (np != length(Rad)) {
            Rad  <<- numeric(length=np)               # Radius of ice sheet
            Vais <<- numeric(length=np)               # Ice volume
            SLE  <<- numeric(length=np)               # Sea-level equivalent [m]
        }

        mp <- c(
          mp,
          Tf    = -1.8,             #Freezing temperature of sea water
          rho_w = 1030,             #Density of sea water [g/cm^3]
          rho_i =  917,             #Density of ice water [g/cm^3]
          rho_m = 4000,             #Density of rock [g/cm^3]
          Toc_0 = 0.72,             #Present day high latitude ocean subsurface temperature [K]
          Rad0  = 1.8636e6          #Steady state AIS radius for present day Ta and SL [m]
        )

        .Call("daisOdeC", list(mp=mp, frc=forcings, out=list(Rad, Vais, SLE)), PACKAGE="dais")

        return (SLE)
    }


static DL_FUNC get_deSolve_gparms;
    //get_deSolve_gparms = R_GetCCallable("deSolve", "get_deSolve_gparms");



void daisOdeInit(void (*odeparms)(int *, double *))
{
    SEXP gparms;

    gparms = (SEXP) get_deSolve_gparms();

    daisInit(gparms);
}



    if (initial || ncol(assimctx$chain) != length(init_mp) + length(init_sp)) {
        print("using initial scale")
    } else {
        print("using proposal matrix")
        scale <- assimProposalMatrix(assimctx$chain, mult=0.5)
        assimctx$init_mp <- assimctx$out$final[  assimctx$mp_indices ]
        assimctx$init_sp <- assimctx$out$final[ -assimctx$mp_indices ]
    }


    init_sp <- assimctx$init_sp
    init_sp["sigma"] <- init_sp["sigma"] - 0.1

    #Shaffer [2014] best guess parameters
    #p  <- c(IP, sigma)
    #p0 <- c(2.1, 0.29, 8, 0.015, 0.4, 0.04, 1.0, 1450, 90, 770, 0.0005, 0.8)
    #p0 <- optim(p0, function(p) - log.post(p))$par
    #print(round(p0, 4))

    #from DEoptim:  Iteration: 500 bestvalit: 5.451840 bestmemit:    1.121505    0.588379    5.814542    0.006010    0.524897    0.059937    1.312585  918.254634   47.567725  823.865213    0.000640    0.277760
