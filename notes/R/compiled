static R_INLINE int foo()

If one does use the .C function to pass a list as an argument, it is visible to the routine as an array in C of SEXP types (i.e., SEXP *). The elements of the array correspond directly to the elements of the R list. However, this array must be treated as read-only and one must not assign values to its elements within the C routine - doing so bypasses R's memory management facilities and will corrupt the object and the R session.

Neither .Call nor .External copy their arguments. You should treat arguments you receive through these interfaces as read-only.


.Call("convolve2", a, b)

#include <R.h>
#include <Rinternals.h>
     
SEXP convolve2(SEXP a, SEXP b)


LISTSXP is a pairlist
    args are passed this way for the .External interface

VECSXP is a list
    isNewList checks

    List elements can be retrieved or set by direct access to the elements of the generic vector. Suppose we have a list object

         a <- list(f=1, g=2, h=3)

    Then we can access a$g as a[[2]] by

           double g;
             ....
           g = REAL(VECTOR_ELT(a, 1))[0];

    length() works here as well

    see getListElement() in "5.9.6 Handling lists"


If efficiency is essential, the macro versions of the accessors can be obtained by defining "USE_RINTERNALS" before including Rinternals.h. If you find it necessary to do so, please do test that your code compiled without ‘USE_RINTERNALS’ defined, as this provides a stricter test that the accessors have been used correctly.


REALSXP is a double array

    isReal checks
         PROTECT(newSexp = coerceVector(oldSexp, REALSXP));
    or
         PROTECT(newSexp = AS_NUMERIC(oldSexp));

        #include <R.h>
        #include <Rinternals.h>

           SEXP ab;
             ....
           PROTECT(ab = allocVector(REALSXP, 2));
           REAL(ab)[0] = 123.45;
           REAL(ab)[1] = 67.89;
           UNPROTECT(1);

    length(ab)

    REAL() is a function call, so store the result (double*)


this is the way to pass the parameters:
    pass as list...  two members:  gmst and mp

        see Writing R Extensions for manipulating R objects

        from deSolve_utils.c::Initdeparms for extracting mp
            #include <R.h>
            #include <Rdefines.h>

            void Initdeparms(int *N, double *parms)
            {
              int i, Nparms;

              Nparms = LENGTH(de_gparms);
              if ((*N) != Nparms)
                {
                  PROBLEM "Confusion over the length of parms"
                  ERROR;
                } 
              else
                {
                  for (i = 0; i < *N; i++) parms[i] = REAL(de_gparms)[i];
                }
            }

    get_deSolve_gparms

    #include <R.h>
    #include <Rinternals.h>
    #include <R_ext/Rdynload.h>
    #include "deltamethrin.h"

    # from deltamethrin.h:
    #define N_PARMS 63
    static double *_RDy_deltamethrin_parms;

    /* initializer */
    void deltamethrin(void(* odeparms)(int *, double *))
    {
        int Nparms;
        DL_FUNC get_deSolve_gparms;
        SEXP gparms;
        get_deSolve_gparms = R_GetCCallable("deSolve","get_deSolve_gparms");
        gparms = get_deSolve_gparms();
        Nparms = LENGTH(gparms);
        if (Nparms != N_PARMS) {
            PROBLEM "Confusion over the length of parms"
            ERROR;
        } else {
            _RDy_deltamethrin_parms = REAL(gparms);
        }
    }


using dll function

    system("R CMD SHLIB mymod.c")
    dyn.load("mymod.dll")

    parms <- c(k1 = 0.04, k2 = 10000, k3 = 3e+07)
    Y <- c(y1 = 1, y2 = 0, y3 = 0)
    times <- c(0, 0.4 * 10^(0:11))
    out <- ode(Y, times, func = "derivs",
    parms = parms, jacfunc = "jac", dllname = "mymod",
    initfunc = "initmod", nout = 1, outnames = "Sum")

    should use ynames=F?
        does not matter for this...

there is a findInterval() function available to C callers -- see Writing R Extensions

    The algorithm is particularly fast when ilo is set to the last result of findInterval() and x is a value of a sequence which is increasing or decreasing for subsequent calls.

    *mflag equals -1 if x < xt[1], +1 if x >= xt[n], and 0 otherwise.


/* file mymod.c */
#include <R.h>

static double parms[3];
#define k1 parms[0]
#define k2 parms[1]
#define k3 parms[2]

/* initializer */
void initmod(void (* odeparms)(int *, double *))
{
    // store a pointer to a variable to contain the model parameters

    int N=3;
    odeparms(&N, parms);
}


/* Derivatives and 1 output variable */

// neq is the length of y
// t is the time
// y has the integral values
// ydot gets the derivative values -- aka y'

void derivs (int *neq, double *t, double *y, double *ydot,
             double *yout, int *ip)
{
    if (ip[0] <1) error("nout should be at least 1");

    // k are the model parameters from the parms array above
    ydot[0] = -k1*y[0] + k2*y[1]*y[2];
    ydot[2] = k3 * y[1]*y[1];
    ydot[1] = -ydot[0]-ydot[2];

    // yout is additional output values followed by double values as passed by parameter rpar when calling integrator
    // ip defines the contents of yout
    // ip[0] is aka nout -- the number of output variables at the beginning of the yout array
    // ip[1] is the total length of yout
    // ip[2] length of ip
    // ip[n] integer values as passed by parameter ipar when calling integrator

    yout[0] = y[0]+y[1]+y[2];
}


model <- function(t, Y, parameters) {
    with(as.list(parameters), {
        dy1 = -k1 * Y[1] + k2 * Y[2] * Y[3]
        dy3 = k3 * Y[2] * Y[2]
        dy2 = -dy1 - dy3
        list(c(dy1, dy2, dy3))
    })
}


jac <- function(t, Y, parameters) {
    with(as.list(parameters), {
        PD[1, 1] = -k1
        PD[1, 2] = k2 * Y[3]
        PD[1, 3] = k2 * Y[2]
        PD[2, 1] = k1
        PD[2, 3] = -PD[1, 3]
        PD[3, 2] = k3 * Y[2]
        PD[2, 2] = -PD[1, 2] - PD[3, 2]
        return(PD)
    })
}


/* The Jacobian matrix */
void jac(int *neq, double *t, double *y, int *ml, int *mu,
         double *pd, int *nrowpd, double *yout, int *ip)
{
    pd[0]= -k1;
    pd[1]= k1;
    pd[2]= 0.0;
    pd[(*nrowpd)]= k2*y[2];
    pd[(*nrowpd) + 1]= -k2*y[2] - 2*k3*y[1];
    pd[(*nrowpd) + 2]= 2*k3*y[1];
    pd[(*nrowpd)*2]= k2*y[1];
    pd[2*(*nrowpd) + 1] = -k2 * y[1];
    pd[2*(*nrowpd) + 2] = 0.0;
}
/* END file mymod.c */
