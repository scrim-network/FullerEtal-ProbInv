see ?alist
    'alist' handles its arguments as if they described function
     arguments.  So the values are not evaluated, and tagged arguments
     with no value are allowed whereas 'list' simply ignores them.
     'alist' is most often used in conjunction with 'formals'.

    # Argument lists
    f <- function() x
    # Note the specification of a "..." argument:
    formals(f) <- al <- alist(x=, y=2+3, ...=)
    f
    al


delayedAssign(x, value, eval.env = parent.frame(1), assign.env = parent.frame(1)))
    creates a promise

    takes TWO environmnets
        eval.env 	an environment in which to evaluate value
        assign.env 	an environment in which to assign x


eval() takes TWO environments
    envir 	the environment in which expr is to be evaluated. May also be NULL, a list, a data frame, a pairlist or an integer as specified to sys.call.
    enclos 	Relevant when envir is a (pair)list or a data frame. Specifies the enclosure, i.e., where R looks for objects not found in envir. This can be NULL (interpreted as the base package environment) or an environment.


N.B.  from below:  The substitute function will extract the content of the expression slot.


2.1.8 Promise objects

Promise objects are part of R's lazy evaluation mechanism. They contain three slots: a value, an expression, and an environment. When a function is called the arguments are matched and then each of the formal arguments is bound to a promise. The expression that was given for that formal argument and a pointer to the environment the function was called from are stored in the promise.

Until that argument is accessed there is no value associated with the promise. When the argument is accessed, the stored expression is evaluated in the stored environment, and the result is returned. The result is also saved by the promise. The substitute function will extract the content of the expression slot. This allows the programmer to access either the value or the expression associated with the promise.

Within the R language, promise objects are almost only seen implicitly. (In an upcoming release they will never be visible to R code, as they will always be evaluated when accessed.) Actual function arguments are of this type. There is also a delayedAssign function that will make a promise out of an expression. There is generally no way in R code to check whether an object is a promise or not, nor is there a way to use R code to determine the environment of a promise. 


wrapping a function with new defaults....
    check R reference manual...  yes this is gold under "Topic programming" in index

    # yes, changing default parameters is a horror;  tried to do this
    # by computing on the language;  broke R, badly
    #
    runPredict(
        nbatch=nbatch, year=year,
        assimctx=assimctx,
        prctx=prctx,
        forcings=forcings,
        modelfn=modelfn,
        noisefn=noisefn,
        outnames=outnames,
        mcmcChain=mcmcChain,
        xvals=xvals,
        ...
        )


this is LESS seriously fucked:

    new strategy:  force evaluation with get for each missing formal name, then add to list of parms
        will new formals work?

    # these do NOT work;  hence, this cannot be abstracted into a function
    #callobj <- match.call(definition=sys.function(), call=sys.call(), expand.dots=T)
    #callobj <- match.call(definition=runUniformPredict, call=sys.call(), expand.dots=T)

    # these DO work:

    #callobj <- match.call(call=sys.call(), expand.dots=T)
    callobj <- match.call(expand.dots=T)

    passedNames <- names(callobj)[-1]
    formalNames <- names(formals())
    passedInd   <- match(passedNames, formalNames)
    dotted      <- formalNames == "..."
    nomatch     <- is.na(passedInd)
    if (any(nomatch)) {
        if (any(dotted)) {
            passedInd <- passedInd[ !nomatch ]
        } else {
            stop("extra arguments passed without ... in formal parameters")
        }
    }
    passedInd <- append(passedInd, which(dotted))

    newNames <- formalNames[ -passedInd ]
    newArgs <- mget(newNames, envir=as.environment(-1), inherits=T)
    callobj <- as.call(c(as.list(callobj), newArgs))
    callobj[[1]] <- as.name("runPredict")
    eval.parent(callobj)

note, that this didn't work either:
    callNewDefaults <- function(fnname, callobj=match.call(expand.dots=T))


this is seriously fucked, although I am not sure why:

    chokes on matrix trying to get year for xvals in evaluating promise
        has to do with environment of assign/environment of evaluation
            environment of evaluation should include the environment of formals in addition to the environment of the caller

    # no match found for argument ... in initParms()
    #callobj <- match.call(expand.dots=F)

    # Error in noisefn[[j]] : subscript out of bounds
    callobj <- match.call(expand.dots=T)

    formals     <- formals()
    passedNames <- names(callobj)[-1]
    formalNames <- names(formals)
    passedInd   <- match(passedNames, formalNames)
    dotted      <- (formalNames == "...")
    nomatch     <- is.na(passedInd)
    if (any(nomatch)) {
        if (any(dotted)) {
            passedInd <- passedInd[ !nomatch ]
        } else {
            stop("extra arguments passed without ... in formal parameters")
        }
    }
    passedInd <- append(passedInd, which(dotted))
    callobj <- as.call(c(as.list(callobj), formals[ -passedInd ]))

    print(callobj)

    # should use parent.frame(1) instead?
    # parent.frame(n) is a convenient shorthand for sys.frame(sys.parent(n)) 

    callobj[[1]] <- as.name("runPredict")
    #eval(callobj)

    # these should be identical:
    eval(callobj, parent.frame())

    # also:
    eval.parent(callobj)

    #eval(callobj, sys.frame(sys.parent()))


what type of object is this?
    formals(runUniformPredict)[[3]] == formals(runUniformPredict)[[4]]
        is.na no good
        is.null no good


formals(function (x=b,y) x)$x

> source('roblib.R')
> formals(colQuantile)
$x


$probs
c(0.025, 0.975)

$...


> typeof(formals(colQuantile))                                                                                                              
[1] "pairlist"
> names(formals(colQuantile))
[1] "x"     "probs" "..."  
> formals(colQuantile)[[1]]

> formals(colQuantile)[[2]]                                                                                                                 
c(0.025, 0.975)

> for (i in formals(colQuantile)) print(i)
Error in print(i) : argument "i" is missing, with no default

> for (i in 1:length(formals(colQuantile))) { print(formals(colQuantile)[[i]]) }

c(0.025, 0.975)

> for (i in 1:length(formals(colQuantile))) { print(formals(colQuantile)[[i]]); print(typeof(formals(colQuantile)[[i]])) }

[1] "symbol"
c(0.025, 0.975)
[1] "language"

[1] "symbol"
