match.arg uses formal argument if no second arg provided to match.arg

    function (object, f, classes = "ANY", deflt = NULL, how = c("unlist", 
        "replace", "list"), ...) 
    {
        if (typeof(object) != "list") 
            stop("'object' must be a list")
        how <- match.arg(how)
        res <- .Internal(rapply(object, f, classes, deflt, how))
        if (how == "unlist") 
            unlist(res, recursive = TRUE)
        else res
    }

looking at the definition of match.arg is informative

    function (arg, choices, several.ok = FALSE) 
    {
        if (missing(choices)) {
            formal.args <- formals(sys.function(sys.parent()))
            choices <- eval(formal.args[[deparse(substitute(arg))]])
        }
        if (is.null(arg)) 
            return(choices[1])
        else if (!is.character(arg)) 
            stop("'arg' must be NULL or a character vector")
        if (!several.ok) {
            if (identical(arg, choices)) 
                return(arg[1])
            if (length(arg) > 1) 
                stop("'arg' must be of length 1")
        }
        else if (length(arg) == 0) 
            stop("'arg' must be of length >= 1")
        i <- pmatch(arg, choices, nomatch = 0L, duplicates.ok = TRUE)
        if (all(i == 0L)) 
            stop(gettextf("'arg' should be one of %s", paste(dQuote(choices), 
                collapse = ", ")), domain = NA)
        i <- i[i > 0]
        if (!several.ok && length(i) > 1) 
            stop("there is more than one match in 'match.arg'")
        choices[i]
    }
