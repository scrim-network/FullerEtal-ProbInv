see match.arg

nargs()

?hasArg(name)

see part of definition of callNextMethod:
    if (nargs() > 0) {
        call <- sys.call()
        call[[1]] <- as.name(".nextMethod")
        eval(call, callEnv)
    }
    else {
        if (subsetCase) {
            call <- as.list(mcall)
            if (identical(f, "[") && length(names(call) > 0)) 
                call <- .doSubNextCall(call, method)
            else {
                fnames <- c("", formalArgs(method))
                i <- match("...", fnames)
                if (is.na(i) || i > length(call)) 
                  length(fnames) <- length(call)
                else {
                  i <- i - 1
                  length(fnames) <- i
                  fnames <- c(fnames, rep("", length(call) - 
                    i))
                }
                names(call) <- fnames
                call <- as.call(call)
            }
        }
        else call <- match.call(method, mcall, expand.dots = FALSE)
        .Call("R_nextMethodCall", call, callEnv, PACKAGE = "methods")

A more elaborate application is in update.default where a set of optional extra arguments can add to, replace, or cancel those of the original call:
     extras <- match.call(expand.dots = FALSE)$...
     if (length(extras) > 0) {
         existing <- !is.na(match(names(extras), names(call)))
         for (a in names(extras)[existing]) call[[a]] <- extras[[a]]
         if (any(!existing)) {
             call <- c(as.list(call), extras[!existing])
             call <- as.call(call)
         }
     }
