plotfn()
    #text(par("usr")[2] - plotUnits(inches, horiz=T), par("usr")[4] - plotUnits(inches), labels=c(w_eqn, w_r2_eqn), adj=c(1, 1), col=warmCol)
    #text(par("usr")[2] - plotUnits(inches, horiz=T), par("usr")[4] - plotUnits(inches), labels=list(w_eqn, w_r2_eqn), adj=c(1, 1), col=warmCol)

    # not at same height
    #text(par("usr")[2] - plotUnits(inches, horiz=T),                      par("usr")[4] - plotUnits(inches), labels=w_r2_eqn, adj=c(1, 1), col=warmCol)
    #text(par("usr")[2] - plotUnits(inches, horiz=T) - strwidth(w_r2_eqn), par("usr")[4] - plotUnits(inches), labels=w_eqn,    adj=c(1, 1), col=warmCol)


    # original attempt
    #text(par("usr")[2] - plotUnits(inches, horiz=T), par("usr")[4] - plotUnits(inches), labels=w_eqn, adj=c(1, 1), col=warmCol)
    #text(par("usr")[2] - plotUnits(inches, horiz=T), par("usr")[4] - plotUnits(inches) - strheight("foo"), labels=w_r2_eqn, adj=c(1, 1), col=warmCol)


plotLinearFit <- function(x, y, col="black", lty="solid", lwd=2)
{
    fit   <- lm(y ~ x)
    inv   <- lm(x ~ y)
    print(paste(coef(fit)[2], coef(inv)[2], 1/(coef(fit)[2])))
   #c     <- coef(fit)
    pts_x <- range(x)
    pts_y <- predict(fit, newdata=data.frame(x=pts_x))
   #pts_y <- pts_x * c[2] + c[1]
    pts_y <- constrain(pts_y, range(y))
   #pts_x <- (pts_y - c[1]) / c[2]
    pts_x <- predict(inv, newdata=data.frame(y=pts_y))
    lines(pts_x, pts_y, col=col, lty=lty, lwd=lwd)
}


from condMeans()
    sums_y <- numeric(length=nbins)
    for (i in 1:length(y)) {
        bin <- binned_y[i]
        sums_y[ bin ] <- sums_y[ bin ] + y[i]
    }

    print(midpts_x)
   #print(length(midpts_x))
    print(binned_y)
   #print(length(binned_y))
    print(counts_y)
   #print(length(counts_y))

   #means <- condMeans(chains[[i]][, topColumn], chains[[i]][, sideColumn])
   #lines(lowess(means, f=0.25), lwd=2, col="black")
   #lines(means, lwd=2, col="black")


figLambda <- function(assimctx=daisctx, prctx=prdaisctx, outline=F, lambda=T, outfiles=T, filetype="pdf")
{
    newDev(ifelse(lambda, "fig3_lambda", "fig3_Tcrit"), outfile=outfiles, width=4, height=8, filetype=filetype)

   #layout(cbind(matrix(1:4, nrow=2, byrow=T), matrix(5:8, nrow=2, byrow=T)), widths=rep(c(10, 3), 2), heights=c(3, 10))
    layout(matrix(1:8, nrow=4, byrow=T), widths=c(10, 3), heights=rep(c(3, 10), 2))

    # limits for SLE
    xlim <- c(0, 0.8)

    if (lambda) {
        # limits for lambda
       #ylim <- c(-.016, .016)
        ylim <- c(.004, .016)
        sideColumn <- "lambda"
    } else {
       #ylim <- c(-41, -9)
        ylim <- c(-21, -9)
        sideColumn <- "Tcrit"
    }

    cnames <- "Uniform"
    units <- assimctx$units
    units <- append(units, "m")
    names(units)[length(units)] <- "2100"

    if (is.null(assimctx$noRejChain)) {
        daisRejSample(assimctx=assimctx, prctx=prctx)
    }

    pre_chain  <- cbind(assimctx$noRejChain, prdaisctx$prNoRejChain)
    burned_ind <- burnedInd(assimctx$noRejChain)
    pre_chain  <- pre_chain[burned_ind, ]
    post_chain <- cbind(assimctx$chain, prdaisctx$prchain)

    points <- ifelse(outline, 1e5, 6e3)
    method <- ifelse(outline, "outline", "points")
    col    <- plotGetColors(3)

    pairPlot(pre_chain,  layout=F, units=units, xlim=xlim, ylim=ylim, method=method,
        topColumn="2100", sideColumn=sideColumn, legends=cnames, points=points, label="a", col=col, smoothing=rep(1.5, 3))

    pairPlot(post_chain, layout=F, units=units, xlim=xlim, ylim=ylim, method=method,
        topColumn="2100", sideColumn=sideColumn, legends=cnames, points=points, label="b", col=col, smoothing=rep(1.5, 3))

    caption <- paste("Figure n. Diagnosing Uniform Inversion; (a) Before rejection sampling, (b) After rejection sampling")
    mtext(caption, outer=TRUE, side=1, font=2)

    if (outfiles) { finDev() }
}


iceflux <- function(mp, forcings, assimctx=daisctx)
{
    assimlst            <- list()
    assimlst$frc        <- forcings

    # TODO:  models.R needs to grab assimctx$sw from daisctx if it's available
    assimlst$ep         <- assimctx$ep
    assimlst$sw         <- assimctx$sw
    assimlst$daisCmodel <- assimctx$daisCmodel

    return (assimctx$modelfn(mp, assimlst))
}


daisRunPredictSlow <- function(nbatch=3500, endYear=2100, assimctx=daisctx, prctx=prdaisctx)
{
    prctx$assimctx <- assimctx

    print(colMean(assimctx$chain))

    frc_ts <- tsTrim(assimctx$forcings, endYear=endYear)
    frc    <- frc_ts[ , 2:ncol(assimctx$forcings) ]
   #prctx$prchain <- prmatrix(nbatch, xvals=frc_ts[, "time"])
    prctx$prchain <- prmatrix(nbatch, xvals= assimctx$expert_std_yr : endYear )

    years   <- nrow(frc)
    rows    <- 1:nbatch
    samples <- sample(burnedInd(assimctx$chain), nbatch, replace=T)
    while (T) {
        for (i in rows) {

            # Run the model.
            sle   <- iceflux(assimctx$chain[samples[i], assimctx$mp_indices], frc, assimctx)

            # Standardize the anomaly.
            anom  <- sle - sle[assimctx$SL.expert]

            # Add noise.  Or not.
           #prctx$prchain[i, ] <- anom # + rnorm(years, sd=sqrt(assimctx$chain[samples[i], "var"]))
            prctx$prchain[i, ] <- anom[ assimctx$SL.expert : length(anom) ]
        }

        # look for NaNs (non-finite)
        rows <- which(apply(prctx$prchain, MARGIN=1, FUN=function(x) { any(!is.finite(x)) }))
        if (!length(rows)) {
            break;
        }
        print(c("resampling", length(rows), "non-finite rows"))
        samples[rows] <- sample(burnedInd(assimctx$chain), length(rows), replace=T)
    }

    # reduce save file size
   #prTrimChains(prctx=prctx, lower=assimctx$expert_std_yr)
}


daisRunKelseyPredict <- function(nbatch=3500, endYear=2300, assimctx=daisctx)
{
    # Identify the burn-in period and subtract it from the chains.
    chain <- assimctx$chain[ burnedInd(assimctx$chain), ]
    DAIS_chains_burnin <<- chain

    # Find mean of the estimated parameters.
    mean.parameters <<- colMean(chain)
    print(mean.parameters)

    # Estimate mean bias.
    bias.mean <<- sqrt(mean.parameters["var"])

    #
    # Make projections.
    #
    frc   <- tsTrim(assimctx$forcings, endYear=endYear)[ , 2:ncol(assimctx$forcings) ]
    years <- nrow(frc)
    proj.mcmc.anomaly   <<- matrix(nrow=nbatch, ncol=years)
    proj.mcmc.1961_1990 <<- matrix(nrow=nbatch, ncol=years)

    # Sample from the chain.
    par.mcmc <- sampleChain(chain, nbatch)
    samples  <- 1:nbatch
    while (T) {
        for (i in samples) {

            # Run the model.
            sle   <- iceflux(par.mcmc[i, assimctx$mp_indices], frc, assimctx)

            # Standardize the anomaly.
            anom  <- sle - mean(sle[assimctx$SL.1961_1990])
            proj.mcmc.anomaly  [i, ] <<- anom

            # Add noise.
            proj.mcmc.1961_1990[i, ] <<- anom + rnorm(years, sd=sqrt(par.mcmc[i, "var"]))
        }

        # look for NaNs (non-finite)
        samples <- which(apply(proj.mcmc.1961_1990, MARGIN=1, FUN=function(x) { any(!is.finite(x)) }))
        if (!length(samples)) {
            break;
        }
        print(c("resampling", length(samples), "non-finite rows"))
        par.mcmc[samples, ] <- sampleChain(chain, length(samples))
    }

    #--------------------- Estimate PDFs, CDFs, and SFs in certain years --------------------------
    # Function to find SLE values in certain years 'fn.prob.proj'
    year.pcs <<- tsGetIndices(assimctx$forcings, c(-118000, -18000, -4000, 2002, 2050, 2100, 2300))

    mcmc.prob_proj <<- fn.prob.proj(proj.mcmc.1961_1990, year.pcs, nbatch, un.constr=T)

    # Calculate the pdf, cdf, and sf of AIS melt estimates in:
    LIG.sf.mcmc  <<- plot.sf(mcmc.prob_proj[,1], make.plot=F) # 120,000 BP (Last interglacial)
    LGM.sf.mcmc  <<- plot.sf(mcmc.prob_proj[,2], make.plot=F) # 20,000 BP (Last glacial maximum)
    MH.sf.mcmc   <<- plot.sf(mcmc.prob_proj[,3], make.plot=F) # 6,000 BP (Mid-holocene)
    sf.2002.mcmc <<- plot.sf(mcmc.prob_proj[,4], make.plot=F) # 2002 (Observed trend from 1993-2011)
    sf.2050.mcmc <<- plot.sf(mcmc.prob_proj[,5], make.plot=F) # 2050
    sf.2100.mcmc <<- plot.sf(mcmc.prob_proj[,6], make.plot=F) # 2100
    sf.2300.mcmc <<- plot.sf(mcmc.prob_proj[,7], make.plot=F) # 2300

    # Find out parameter relationships; set up a matrix
    d.pos_parameters <<- par.mcmc
    sub_chain        <<- par.mcmc

    # random stuff MCMC_plots.R uses
    enddate          <<- years
    mean.dais.par    <<- mean.parameters
    project.forcings <<- frc
    standards        <<- NULL
    windows          <<- assimctx$windows
    bound.lower      <<- assimctx$lbound
    bound.upper      <<- assimctx$ubound
    subset_length    <<- nbatch
    obs.years        <<- assimctx$obs_ind
}


# save this;  interesting contour treatment
figUber2 <- function(assimctx=as1)
{
    newDev("fig3_2", outfile=outfiles, width=8.5, height=4.25, filetype=filetype)

    layout(cbind(matrix(1:4, nrow=2, byrow=T), matrix(5:8, nrow=2, byrow=T)), widths = rep(c(10, 3), 2), heights = c(3, 10))

    points <- 1e5

    xlim <- c(assimctx$lbound["Tcrit"],  assimctx$ubound["Tcrit"])
    ylim <- c(assimctx$lbound["lambda"], assimctx$ubound["lambda"])

    col   <- c("#D00000", "#0000D0")
    n     <- 31
    reds  <- paste("#",     toupper(as.hexmode(floor(seq(128, 255, length.out=n)))), "0000", as.hexmode(200), sep="")
    blues <- paste("#0000", toupper(as.hexmode(floor(seq(128, 255, length.out=n)))),         as.hexmode(200), sep="")
    ccol  <- list(reds, blues)

    #n <- 31; pie(rep(1, n), col=paste("#", toupper(as.hexmode(floor(seq(128, 255, length.out=n)))), "0000", as.hexmode(200), sep=""))

    pairPlot( as1$chain,  as2$chain, topColumn="Tcrit", sideColumn="lambda",
        layout=F, units=assimctx$units, xlim=xlim, ylim=ylim, method="contours",
        legends=cnames[1:2], points=points, label="a", col=col, ccol=ccol)

    pairPlot(ias1$chain, ias2$chain, topColumn="Tcrit", sideColumn="lambda",
        layout=F, units=assimctx$units, xlim=xlim, ylim=ylim, method="contours",
        legends=cnames[1:2], points=points, label="b", col=col, ccol=ccol)

    caption <- paste("Figure 3. Inferred prior probability; (a) Expert assessment only, (b) All data")
    mtext(caption, outer=TRUE, side=1, font=2)

    if (outfiles) { finDev() }
}

figPredict()
    # figure title
    #caption <- paste("Figure 4. Probabilistic inversion with paleo and instrumental observations")
    #mtext(caption, outer=F, line=4, side=1, font=2)

figInfer()
   #caption <- paste("Figure 3. Inferred prior probability; (a) Expert assessment only, (b) All data")
   #mtext(caption, outer=TRUE, side=1, font=2)

figAisPriors()
   #caption <- paste("Figure 1. Probabilistic inversion of expert assessment with different priors")
   #mtext(caption, outer=F, line=4, side=1, font=2)

figCmpPriors()
            xlim    <- NULL
        } else {
            xlim    <- assimctx$windows[assimctx$expert_ind, ]
            margin  <- (xlim[2] - xlim[1]) * .05
            xlim[1] <- xlim[1] - margin
            xlim[2] <- xlim[2] + margin
        }

if (0) {
        if (assimctx$prior_name == "uniform") {
            smoothing <- 0.50
        } else {
            smoothing <- 1.25
        }
}

    # figure title
   #caption <- paste("Figure 2. Probabilistic inversion of expert assessment by prior")
   #mtext(caption, outer=TRUE, side=1, font=2)


pr1$assimctx <- as1
pr2$assimctx <- as2
pr3$assimctx <- as3
ipr1$assimctx <- ias1
ipr2$assimctx <- ias2
ipr3$assimctx <- ias3


    #print(min(densEst$y)) # [ densEst$y > 0 ]))
    #print(max(densEst$y))

    #print(min(h_x))
    #print(max(f_x))


cdfCalc <- function(..., column=NULL, chains=list(...), survival=F)
{
    xlim <- numeric()
    cdfs <- list()

    for (i in 1:length(chains)) {
        if (is.null(column)) {
            chain <- chains[[i]]
        } else {
            chain <- chains[[i]][, column]
        }
        xlim <- range(chain, xlim)
        cdfs[[i]] <- ecdf(chain)
    }

    return (env(xlim=xlim, cdfs=cdfs, survival=survival))
}


    xlim <- par("usr")[1:2]


restrictEnvironment <- function(f,varList) {
  oldEnv <- environment(f)
  newEnv <- new.env(parent=parent.env(oldEnv))
  for(v in varList) {
    assign(v,get(v,envir=oldEnv),envir=newEnv)
  }
  environment(f) <- newEnv
  f
}


        cdf <- ecdf(chain)
        if (survival) {
            cdfs[[i]] <- restrictEnvironment(function(x) { 1 - cdf(x) }, 'cdf')
        } else {
            cdfs[[i]] <- cdf
        }


if (0) {
    newDev("ais_2100_2", outfile=outfiles, width=6, height=6, filetype=filetype)
    pdfPlots(
        chains=list(pr1$prchain, pr2$prchain),
        column=as.character(2100),
        lty=c("solid", "dashed"),
        #lty=rep("solid", 2),
        legends=c("Uniform", "Beta"),
        col=c("blue", "green"),
        burnin=F,
    #    xlim=c(0, max(cictx$range)),
        xlab=xlab,
        lwd=2,
        smoothing=c(0.50, 1.5),
        yline=2
        )
}

    #caption <- paste("Figure n. Probability density function of AIS volume loss in year", year)
    #mtext(caption, outer=T, side=1)
    #mtext(caption, outer=T, side=1, font=2)
    #mtext(caption, outer=F, line=4, side=1, font=2)

prchain <- cbind( prdaisctx$prchain[, as.character(year) ] )
colnames(prchain) <- paste("Projected AIS Volume Loss in", year, "[SLE m]")
pdfplot(mcmcChain=prchain, units="m", chartRow=1, chartCol=1,
    outfiles=outfiles, burnin=F, width=8, height=8,
    caption=paste("Probability density function of AIS volume loss in year",
        year))

        if (R < 0) {
            Rprintf("volume negative in daisOdeSolve()");
            R = 0;
            Vais(i) = 0;
        } else {
            Vais(i) = Vais(i-1) + (Btot-F+ISO+disint_rate);
        }

if (!is.finite(llik)) {
        recover()
    }

    if (0) {
        # read in optimized parameters
        raw     <- scan("../../../ruckert_dais/DAIS_matlab/OtimizedInitialParameters.txt", what=numeric(), quiet=T)
        init_p  <- matrix(raw, ncol=2, byrow=T)
        init_mp <- init_p[1:11, 2]
        names(init_mp) <- paramNames
    } else {
        #init_p <- c(2.1, 0.29, 8, 0.015, 0.4, 0.04, 1.0, 1450, 90, 770, 0.0005, 0.6) # Kelsey Random guesses
        init_mp <- IP
    }

daisLoadModel <- function(assimctx=daisassimctx)
{
    if (assimctx$fortran) {
        daisModel <<- F_daisModel
    } else {
        daisModel <<- C_daisModel
        dynUnload("dais_alex")
        dynUnload("dais_kelsey")
        if (assimctx$alex) {
            dynLoad("dais_alex",   srcname=c("dais_alex.c",   "r.c"), extrasrc="r.h")
        } else {
            dynLoad("dais_kelsey", srcname=c("dais_kelsey.c", "r.c"), extrasrc="r.h")
        }
    }
}


    bound.lower <- IP - (IP*0.5)
    bound.upper <- IP + (IP*0.5)

    #Set bounds for gamma and alpha
    bound.lower[1:2] <- c( 1/2, 0)
    bound.upper[1:2] <- c(17/4, 1)

    #Set bounds for bo and s
    bound.lower[10:11] <- c(725, 0.00045)
    bound.upper[10:11] <- c(825, 0.00075)


        print(paste(anom[1], last(anom)))
        print(paste(length(anom), length(proj.mcmc.anomaly[i, ])))
        print(paste(proj.mcmc.1961_1990[i, 1]))


if (0) {

    # Estimate model hindcast from parameter means.
    mean.hind.simulation = iceflux(mean.parameters[ assimctx$mp_indices ], assimctx$hindcast.forcings)
    mean.hind.anomaly = mean.hind.simulation - mean(mean.hind.simulation[assimctx$SL.1961_1990]) 
    mean.hindcast = mean.hind.anomaly + rnorm(length(mean.hind.simulation), mean=0, sd=bias.mean)

    # Estimate model projection from parameter means.
    mean.proj.simulation = iceflux(mean.parameters[ assimctx$mp_indices ], assimctx$project.forcings)
    mean.proj.anomaly = mean.proj.simulation - mean(mean.proj.simulation[assimctx$SL.1961_1990])
    mean.projection = mean.proj.anomaly + rnorm(length(mean.proj.anomaly), mean=0, sd=bias.mean)
}    

F_iceflux <- function(iceflux, forcings)
{
    Volume_F <- daisF(
      tstep = 1,
      b0    = iceflux[10],
      slope = iceflux[11],
      mu    = iceflux[3],
      h0    = iceflux[8],
      c     = iceflux[9],
      P0    = iceflux[5],
      kappa = iceflux[6],
      nu    = iceflux[4],
      f0    = iceflux[7],
      gamma = iceflux[1],
      alpha = iceflux[2],
      Tf    = -1.8,             #Freezing temperature of sea water
      rho_w = 1030,             #Density of sea water [g/cm^3]
      rho_i = 917,              #Density of ice water [g/cm^3]
      rho_m = 4000,             #Density of rock [g/cm^3]
      Toc_0 = 0.72,             #Present day high latitude ocean subsurface temperature [K]
      Rad0  = 1.8636e6,         #Steady state AIS radius for present day Ta and SL [m]
      Ta     = forcings[, 1], 
      SL     = forcings[, 4],
      Toc    = forcings[, 2],
      dSL    = forcings[, 3])

    return (Volume_F)
}

daisModel <- function(mp, assimctx)
{
    # this was quite a bit slower
    return (iceflux(mp, assimctx$frc))
}


    iceflux <- function(mp, forcings)
    {
        np <- nrow(forcings)
        if (np != length(Rad)) {
            Rad  <<- numeric(length=np)               # Radius of ice sheet
            Vais <<- numeric(length=np)               # Ice volume
            SLE  <<- numeric(length=np)               # Sea-level equivalent [m]
        }

        mp <- c(
          mp,
          Tf    = -1.8,             #Freezing temperature of sea water
          rho_w = 1030,             #Density of sea water [g/cm^3]
          rho_i =  917,             #Density of ice water [g/cm^3]
          rho_m = 4000,             #Density of rock [g/cm^3]
          Toc_0 = 0.72,             #Present day high latitude ocean subsurface temperature [K]
          Rad0  = 1.8636e6          #Steady state AIS radius for present day Ta and SL [m]
        )

        .Call("daisOdeC", list(mp=mp, frc=forcings, out=list(Rad, Vais, SLE)), PACKAGE="dais")

        return (SLE)
    }


static DL_FUNC get_deSolve_gparms;
    //get_deSolve_gparms = R_GetCCallable("deSolve", "get_deSolve_gparms");



void daisOdeInit(void (*odeparms)(int *, double *))
{
    SEXP gparms;

    gparms = (SEXP) get_deSolve_gparms();

    daisInit(gparms);
}



    if (initial || ncol(assimctx$chain) != length(init_mp) + length(init_sp)) {
        print("using initial scale")
    } else {
        print("using proposal matrix")
        scale <- assimProposalMatrix(assimctx$chain, mult=0.5)
        assimctx$init_mp <- assimctx$out$final[  assimctx$mp_indices ]
        assimctx$init_sp <- assimctx$out$final[ -assimctx$mp_indices ]
    }


    init_sp <- assimctx$init_sp
    init_sp["sigma"] <- init_sp["sigma"] - 0.1

    #Shaffer [2014] best guess parameters
    #p  <- c(IP, sigma)
    #p0 <- c(2.1, 0.29, 8, 0.015, 0.4, 0.04, 1.0, 1450, 90, 770, 0.0005, 0.8)
    #p0 <- optim(p0, function(p) - log.post(p))$par
    #print(round(p0, 4))

    #from DEoptim:  Iteration: 500 bestvalit: 5.451840 bestmemit:    1.121505    0.588379    5.814542    0.006010    0.524897    0.059937    1.312585  918.254634   47.567725  823.865213    0.000640    0.277760
