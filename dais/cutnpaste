print(system.time(for (i in 1:100)
brick_case1 = dais(
  b0    = case1[10],
  slope = case1[11],
  mu    = case1[3],
  h0    = case1[8],
  c     = case1[9],
  P0    = case1[5],
  kappa = case1[6],
  nu    = case1[4],
  f0    = case1[7],
  gamma = case1[1],
  alpha = case1[2],
  Tf    = Tice,
  ro_w  = Dsw*1000,
  ro_i  = Dice*1000,
  ro_m  = Drock*1000,
  Toc_0 = TOo,
  Rad0  = Roa,
  tstep = 1)))

mp <- c(
  b0    = case1[10],
  slope = case1[11],
  mu    = case1[3],
  h0    = case1[8],
  c     = case1[9],
  P0    = case1[5],
  kappa = case1[6],
  nu    = case1[4],
  f0    = case1[7],
  Gamma = case1[1],
  alpha = case1[2],
  Tf    = Tice,
  rho_w = Dsw*1000,
  rho_i = Dice*1000,
  rho_m = Drock*1000,
  Toc_0 = TOo,
  Rad0  = Roa
)

np     <- length(Ta)
Rad    <- numeric(length=np)               # Radius of ice sheet
Vais   <- numeric(length=np)               # Ice volume
SLE    <- numeric(length=np)               # Sea-level equivalent [m]

print(system.time(for (i in 1:100) .Call("daisOdeC", list(mp=mp, frc=hindcast.forcings, out=list(Rad, Vais, SLE)), PACKAGE = "dais")))

if (1) {
    vol1 <- Vais
    .Call("daisOdeC", list(mp=mp, frc=hindcast.forcings, out=list(Rad, Vais, SLE)), PACKAGE = "dais")
    vol2 <- Vais
    print(any(vol1 != vol2))
}



Rprintf("Radius=%f, Vais=%f, mit=%f\n", Rad(1), Vais(1), mit);
        if (i == 2) { Rprintf("Btot is %f\n", Btot); }
            if (i == 3) { Rprintf("speed=%f, F=%f, ISO=%f, Hw=%f\n", Speed, F, ISO, Hw); }
        if (i == 3) { Rprintf("fac=%f\n", fac); }

void allgrgisOdeC(
    int *neq, double *t, double *y, double *ydot,
    double *yout, int *ip)
{
    double s_other, s_gis, temp, masstemp, ds_other, ds_gis, ds_total, max_gis;

    //s_total = y[0];
    s_other   = y[1];
    s_gis     = y[2];
    max_gis   = max_sle;
    if (s_gis > max_gis) {
        s_gis = max_gis;
    }

    temp         = tsFindByDate(    &gmstMat, *t, gmstCol);
    if (sw_old_ref) {
        masstemp = tsFindByDate(&massGmstMat, *t, gmstCol) * gis_scl;
    } else {
        masstemp = (temp + gis_temp) * gis_scl;
    }

    ds_other = (a * temp + b                  - s_other) / tau;

    if (masstemp <= 0) {
        ds_gis   = (masstemp *  c                    - s_gis)   / tau2;
    } else {
        ds_gis   = (masstemp * (c + d * masstemp) - s_gis)   / tau2;
    }
    ds_total = ds_other + ds_gis;

    ydot[0] = ds_total;
    ydot[1] = ds_other;
    ydot[2] = ds_gis;

    if (2 != ip[0]) {
        error("dais.c expects ode(nout=2) for gringisOdeC()");
    }
    yout[0] = ds_gis;
    yout[1] = ds_total;
}


void allgrgisFitOdeC(
    int *neq, double *t, double *y, double *ydot,
    double *yout, int *ip)
{
    double s, temp, ds, max_gis;

    s = y[0];
    max_gis = max_sle;
    if (s > max_gis) {
        s = max_gis;
    }

    if (sw_old_ref) {
        // could get the same effect be setting gis_temp to zero
        temp =  tsFindByDate(&gmstMat, *t, gmstCol) * gis_scl;
    } else {
        temp = (tsFindByDate(&gmstMat, *t, gmstCol) + gis_temp) * gis_scl;
    }
    if (temp <= 0) {
        ds = (temp *  c                - s) / tau2;
    } else {
        ds = (temp * (c + d * temp) - s) / tau2;
    }

    ydot[0] = ds;

    if (1 != ip[0]) {
        error("dais.c expects ode(nout=1) for gringisFitOdeC()");
    }
    yout[0] = ds;
}


static R_NativePrimitiveArgType myC_t[] = {
    REALSXP, INTSXP, STRSXP, LGLSXP
};

static R_CallMethodDef callMethods[]  = {
  {"daisOdeC", (DL_FUNC) &daisOdeC, 0},
  {NULL, NULL, 0}
};

static R_CMethodDef cMethods[] = {
//   {"myC", (DL_FUNC) &daisOdeC, 0, myC_t}
   {"daisOdeC", (DL_FUNC) &daisOdeC, 0, NULL},
   {NULL, NULL, 0}
};


static DL_FUNC get_deSolve_gparms;

void R_init_dais(DllInfo *dll)
{
    get_deSolve_gparms = R_GetCCallable("deSolve", "get_deSolve_gparms");

    sortNamedStructs(realParms);
    sortNamedStructs(parms);
    sortNamedStructs(swParms);
    R_registerRoutines(dll, cMethods, callMethods, NULL, NULL);
